<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"Chord.js.html":{"id":"Chord.js.html","title":"Source: Chord.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: Chord.js import { Note, } from '.' /** * represents a Chord. * @class */ export class Chord { /** * Creates a Chord instance. * @param {Object} attributes gets * {Note/String} root * {Note/String} third * {Note/String} fifth * {Note/String} note4(optional) * {String} duration */ constructor(attributes = {}) { this.attributes = [] this.attributes[Chord.DURATION] = attributes.duration || 'q' this.attributes[Chord.NOTES] = [] this.isChord = true let root = attributes.root, third = attributes.third || null, fifth = attributes.fifth || null, note4 = attributes.note4 || null if (!(root instanceof Note)) { root = new Note({ note: attributes.root }) third = third ? new Note({ note: third }) : null fifth = fifth ? new Note({ note: fifth }) : null note4 = note4 ? new Note({ note: note4 }) : null } if (root instanceof Note) this.attributes[Chord.NOTES][Chord.ROOT] = root if (fifth) { if (root.index &gt; fifth.index) { fifth = new Note({ note: fifth.note, octave: root.octave + 1, duration: fifth.duration, instrument: fifth.instrument, }) } else { fifth = new Note({ note: fifth.note, octave: root.octave, duration: this.duration, instrument: third.instrument }) } this.attributes[Chord.NOTES][Chord.FIFTH] = fifth } if (third) { if (root.index &gt; third.index) { third = new Note({ note: third.note, octave: root.octave + 1, duration: third.duration, instrument: third.instrument, }) } else { third = new Note({ note: third.note, octave: root.octave, duration: third.duration, instrument: third.instrument, }) } this.attributes[Chord.NOTES][Chord.THIRD] = third } if (note4) { if (root.index &gt; third.index) { third = new Note({ note: third.note, octave: root.octave + 1, duration: third.duration, instrument: third.instrument, }) } else { third = new Note({ note: third.note, octave: root.octave, duration: third.duration, instrument: third.instrument, }) } this.attributes[Chord.NOTES][Chord.NOTE4] = note4 } // Major if (root.interval(4).note === third.note) { // Perfect Fifth if (root.interval(7).note === fifth.note) { // Triad if (note4 == null) { this.type = 'Major' this.symbol = '' } // Not Triad else { // Added Fourth if (root.interval(5).note === note4.note) { this.type = 'Added Fourth' this.symbol = 'add4' } // Added Sixth else if (root.interval(9).note === note4.note) { this.type = 'Sixth' this.symbol = '6' } // Major 7th else if (root.interval(11).note === note4.note) { this.type = 'Major 7th' this.symbol = 'Maj7' } // Seventh else if (root.interval(10).note === note4.note) { this.type = 'Seventh' this.symbol = '7' } } } // Diminished Fifth else if (root.interval(6).note === fifth.note) { this.type = 'Major Flat Fifth' this.symbol = 'b5' } // Augmented Fifth else if (root.interval(8).note === fifth.note) { this.type = 'Major Augmented Fifth' this.symbol = 'aug' } } //Minor else if (root.interval(3).note === third.note) { if (root.interval(7).note === fifth.note) { if (note4 == null) { this.type = 'Minor' this.symbol = 'm' } else { if (root.interval(5).note === note4.note) { this.type = 'Minor Added Fourth' this.symbol = 'madd4' } else if (root.interval(9).note === note4.note) { this.type = 'Minor Sixth' this.symbol = 'm6' } else if (root.interval(10).note === note4.note) { this.type = 'Minor Seventh' this.symbol = 'm7' } } } else if (root.interval(6).note === fifth.note) { if (note4 == null) { this.type = 'Diminished' this.symbol = 'dim' } else { if (root.interval(9).note === note4.note) { this.type = 'Diminished Seventh' this.symbol = 'dim7' } } } } if (this.type === undefined) { this.type = 'Unknown' this.symbol = '' this.isChord = false } } static get DURATION() { return 0 } static get NOTES() { return 1 } /** * The index of the root. * @type {Number} * @readonly */ static get ROOT() { return 0 } /** * The index of the third. * @type {Number} * @readonly */ static get THIRD() { return 2 } /** * The index of the fifth. * @type {Number} * @readonly */ static get FIFTH() { return 1 } /** * The index of the fourth note. * @type {Number} * @readonly */ static get NOTE4() { return 3 } /** * The root of the chord as Note * @returns {Note} * @readonly */ get root() { return this.attributes[Chord.NOTES][Chord.ROOT] } /** * The third of the chord as Note * @returns {Note} * @readonly */ get third() { return this.attributes[Chord.NOTES][Chord.THIRD] } /** * The fifth of the chord as Note * @returns {Note} * @readonly */ get fifth() { return this.attributes[Chord.NOTES][Chord.FIFTH] } /** * The fourth note of the chord as Note * @returns {Note} * @readonly */ get note4() { return this.attributes[Chord.NOTES][Chord.NOTE4] } /** * The duration of the chord as String * @returns {String} * @readonly */ get duration() { return this.attributes[Chord.DURATION] } get chordName() { return this.root.note + this.symbol } get notes() { return this.attributes[Chord.NOTES] } // TODO ADD A HALPING METHOD THAT WILL PLAY MELODICALLY IN INTERVAL BY CORRECT ORDER /** * play all the notes in the chord as a melody. */ playMelody() { let self = this for (let i = 0; i &lt; this.attributes[Chord.NOTES].length; i++) { setTimeout(function timer() { self.attributes[Chord.NOTES][i].play() }, i * 500) } } /** * play all the notes in the chord as a harmony. */ play() { for (let i = 0; i &lt; this.attributes[Chord.NOTES].length; i++) this.attributes[Chord.NOTES][i].play() } /** * Transforms the chord into its root position. */ rootPosition() { // TODO } /** * Transforms the chord into its 1st-inversion. */ inversionFirst() { //TODO } /** * Transforms the chord into its 2st-inversion. */ inversionSecond() { //TODO } /** * returns string of the name of the chord and all the notes it contains. */ toString() { if (this.symbol == undefined) { if (this.note4 == null) { return this.root.note + ' {' + this.root + ', ' + this.third + ', ' + this.fifth + '}' } else if (this.note5 == null) { return this.root.note + ' {' + this.root + ', ' + this.third + ', ' + this.fifth + ', ' + this.note4 + '}' } return this.root.note + ' {' + this.root + ', ' + this.third + ', ' + this.fifth + ', ' + this.note4 + ', ' + this.note5 + '}' } else if (this.note4 == null) { return this.root.note + this.symbol + ' {' + this.root + ', ' + this.third + ', ' + this.fifth + '}' } else if (this.note5 == null) { return this.root.note + this.symbol + ' {' + this.root + ', ' + this.third + ', ' + this.fifth + ', ' + this.note4 + '}' } return this.root.note + this.symbol + ' {' + this.root + ', ' + this.third + ', ' + this.fifth + ', ' + this.note4 + ', ' + this.note5 + '}' } newDuration(duration) { return new Chord({ root: this.root.changeDuration(duration), third: this.third ? this.third.changeDuration(duration) : null, fifth: this.fifth.changeDuration(duration), note4: this.note4 ? this.note4.changeDuration(duration) : null, duration: duration }) } tranpose(interval) { const newChordNotes = this.attributes[Chord.NOTES].map(n =&gt; n.interval(interval)) return new Chord({ root: newChordNotes[Chord.ROOT], fifth: newChordNotes[Chord.FIFTH], third: newChordNotes[Chord.THIRD], note4: newChordNotes[Chord.NOTE4], duration: this.duration }) } } × Search results Close Music "},"Scale.js.html":{"id":"Scale.js.html","title":"Source: Scale.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: Scale.js import {Note, Chord, MusicalPattern} from '.' /** * represents a Diatonic Scale(a scale that consists of 7 notes), * @extends MusicalPattern */ export class DiatonicScale extends MusicalPattern { /** * * @param {Note/String} tonic Root of the Scale * @param {Array} pattern Intervals for the other notes(from the tonic). */ constructor(tonic, pattern) { super(tonic, pattern) this.chords = [] this.show = false for (let i in this.notes.slice(0, 7)) this.chords.push(new Chord({ root: this.notes[i], third: this.notes[(parseInt(i) + 2) % 7], fifth: this.notes[(parseInt(i) + 4) % 7], })) } /** * returns the x chord of the scale. * @param {number} chord Chord Number */ getChord(chord) { return this.chords[chord - 1] != undefined ? this.chords[chord - 1] : null } /** * returns array with all the chords in the scale. */ getChords() { return this.chords } } × Search results Close Music "},"MusicalPattern.js.html":{"id":"MusicalPattern.js.html","title":"Source: MusicalPattern.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: MusicalPattern.js import { Note, piano } from '.' /** * Represents a musical pattern. */ export class MusicalPattern { /** * @param {String/Note} tonic * @param {Array} pattern *@constructor */ constructor(tonic, pattern) { if (tonic instanceof Note) { this.tonic = tonic } else { this.tonic = new Note({ note: tonic }) } this.pattern = pattern this._notes = [] for (let j of pattern) this._notes.push(this.tonic.interval(j)) this._notes.push(this.tonic.interval(12)) } /** * returns array that contains all the notes in the pattern. */ get notes() { return this._notes } /** * returns a string of all the notes in the pattern */ toString() { let str = '' for (let i = 0; i &lt; this.notes.length - 1; ++i) str += this.notes[i] + ', ' str += this.notes[this.notes.length - 1] return str } /** * returns the interval inside the Scale * for example - if the Scale is a C Major, * than interval(1) wiil return D. * @param {number} interval */ interval(interval) { let counter = 0 for (let i = 0; i &lt; interval; i++) counter += this.pattern[i] return this.tonic.interval(counter) } /** * play all the notes in the pattern one after the other. */ play() { let self = this for (let i = 0; i &lt; this.notes.length; i++) { setTimeout(function timer() { self.notes[i].play() }, i * 500) } } } × Search results Close Music "},"Key.js.html":{"id":"Key.js.html","title":"Source: Key.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: Key.js import {Note, Chord, DiatonicScale} from '.' /** * represents a Musical Key that is based on a specific Diatonic Scale., * @extends DiatonicScale */ export class Key extends DiatonicScale { constructor(tonic, pattern) { super(tonic, pattern) } addChordProgression(chords) { } } export default Key × Search results Close Music "},"Measure.js.html":{"id":"Measure.js.html","title":"Source: Measure.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: Measure.js import { Note, Chord, note_durations } from '.' import { isArray, } from 'util' import { getMinDuration } from './Addons' /** * Measure - represents a single measure as part of a musical piece. * @class */ export class Measure { /** * Creates a Measure instance * @param {Array} data An array which contains notes or chords * @param {Number} max_duration Max duration of the measure(decided by time signature) */ constructor(max_duration = 0) { this.attributes = [] this.attributes[Measure.NOTES] = [] this.attributes[Measure.MAX_DURATION] = max_duration this.attributes[Measure.DURATION] = 0 } static get NOTES() { return 0 } static get DURATION() { return 1 } static get MAX_DURATION() { return 2 } /** * Array of all the notes in the measure */ get notes() { return this.attributes[Measure.NOTES] } /** * Assign new notes to measure */ set notes(notes) { this.attributes[Measure.NOTES] = notes } /** * Returns a new array with the same notes. */ getData() { const notes = [] this.notes.forEach(i =&gt; notes.push(i)) return notes } /** * get the duration */ get duration() { return this.attributes[Measure.DURATION] } /** * set the duration */ set duration(duration) { this.attributes[Measure.DURATION] = duration } get max_duration() { return this.attributes[Measure.MAX_DURATION] } isFull() { return this.duration == this.max_duration &amp;&amp; this.max_duration != 0 } /** * Change notes somewhere inside a measure * @param {Number} index The index where the notes will be changed * @param {Array/Note} new_notes Notes to change to */ mutate(i, new_notes) { const new_data = JSON.parse(JSON.stringify(this.notes)) new_data[i] = new_notes const new_measure = new Measure(this.max_duration) new_measure.pushNotes(new_data) return new_measure } get duration_left() { return this.max_duration - this.duration } /** * Push notes to a measure * @param {Array} notes array of notes */ push(notes = []) { let verified_notes = [] notes.forEach((note) =&gt; { if (note_durations[note.duration] &lt;= this.duration_left || this.max_duration === 0) verified_notes.push(note) }) this.notes.push(verified_notes) this.duration += getMinDuration(verified_notes) } /** * Add notes to the end of the measure * @param {Array} note_arrays array of arrays of notes */ pushNotes(note_arrays) { note_arrays.forEach(note_array =&gt; this.push(note_array)) } pop(){ this.notes.splice(this.notes.length-1, 1) } updateDuration() { let valid = 0 this.notes.some((notes) =&gt; { if (this.duration &lt;= this.max_duration || this.max_duration === 0) { valid++ } else return true }) this.notes = this.notes.slice(0, valid) } transpose(interval) { const new_notes = this.notes.map(n =&gt; n.map(note =&gt; note.interval(parseInt(interval)))) const new_measure = new Measure(this.max_duration) new_measure.pushNotes(new_notes) return new_measure } toString() { let string = 'Measure: { ' for (const i of this.notes) if (i instanceof Note || i instanceof Chord) { string += i.toString() + ', ' } else { string += '[ ' for (const j of i) string += j + ', ' string += '] ' } string += '} ' return string } } × Search results Close Music "},"Note.js.html":{"id":"Note.js.html","title":"Source: Note.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: Note.js import { firstToUpper, notes, circle_of_fourths, semitone } from \".\" import { Howl } from \"howler\" const sounds = new Map() /** * @class * @classdesc Represents a single musical note. * @example * const n = new Note({note: 'c', octave: 3, duration: 'q', instrument: 'Piano'}) */ export class Note { /** * @param {Object} attributes Object that contains some or all of the following keys: * {String} note Musical Note * {number} octave Note Octave * {String} duration Note duration * {String} instrument Piano/Guitar/etc... */ constructor(attributes = {}) { const note = attributes.note ? firstToUpper(attributes.note) : \"A\" this.attributes = [] this.attributes[Note.NOTE] = !notes[\"#\"].includes(note) &amp;&amp; !notes.b.includes(note) ? \"A\" : note this.attributes[Note.OCTAVE] = attributes.octave &gt;= 0 &amp;&amp; attributes.octave &lt;= 7 ? attributes.octave : 3 this.attributes[Note.DURATION] = attributes.duration || \"q\" this.attributes[Note.INSTRUMENT] = attributes.instrument ? firstToUpper(attributes.instrument) : \"Piano\" this.attributes[Note.FAMILY] = circle_of_fourths.includes(this.note) ? \"b\" : \"#\" this.attributes[Note.INDEX] = notes[this.family].indexOf(this.note) this.attributes[Note.FREQUENCY] = this.calculateFrequency() Note.setSound(this) } /** * Index of note in attributes * @type {Number} * @readonly */ static get NOTE() { return 0 } /** * Index of octave in attributes * @type {Number} * @readonly */ static get OCTAVE() { return 1 } /** * Index of duration in attributes * @type {Number} * @readonly */ static get DURATION() { return 2 } /** * Index of instrument in attributes * @type {Number} * @readonly */ static get INSTRUMENT() { return 3 } /** * Index of family in attributes * @type {Number} * @readonly */ static get FAMILY() { return 4 } /** * Index of note index in attributes * @type {Number} * @readonly */ static get INDEX() { return 5 } /** * Index of frequency in attributes * @type {Number} * @readonly */ static get FREQUENCY() { return 6 } /** * Gets a note and creates it's active Howl player in the notes hash-table so we can play it * @param {Note} note * @private */ static setSound(note) { const key = note.instrument + notes[\"b\"][notes[note.family].indexOf(note.note)] + note.octave if (!sounds.has(key)) { const filePath = \"https://note-art.azurewebsites.net/\" + note.instrument + \"/\" + \"FF_\" + notes[\"b\"][notes[note.family].indexOf(note.note)] + note.octave + \".mp3\" sounds.set( key, new Howl({ src: [filePath] }) ) } } /** * Returns the note alphabet representation as a string. * @type {String} * @readonly */ get note() { return this.attributes[Note.NOTE] } /** * Get octave of note. * @type {Number} * @readonly */ get octave() { return this.attributes[Note.OCTAVE] } /** * Get the duration of a note * @type {String} * @readonly */ get duration() { return this.attributes[Note.DURATION] } /** * Get the instrument that plays the note * @type {String} * @readonly */ get instrument() { return this.attributes[Note.INSTRUMENT] } /** * Get the family of notes the note belnogs to - sharps or flats * @type {String} * @readonly */ get family() { return this.attributes[Note.FAMILY] } /** * Set the notes family in case needed. * @type {String} */ set family(l) { this.attributes[Note.family] = l == \"#\" || l == \"b\" ? l : this.family } /** * Get the index of the note from the 12 notes (C, Db, etc...). * @type {String} * @readonly */ get index() { return this.attributes[Note.INDEX] } /** * Get the frequency of the note. * @type {String} * @readonly */ get frequency() { return this.attributes[Note.FREQUENCY] } /** * Calculate the frequancy of a note. * @type {Number} * @private */ calculateFrequency() { let octave_interval = this.octave - 4 //calculate octave difference return Math.pow(semitone, this.index - 9 + octave_interval * 12) * 440 } /** * returns a clone of the note(new instance). * @type {Note} */ clone() { return new Note({ note: this.note, octave: this.octave, duration: this.duration, instrument: this.instrument }) } /** * returns a clone of the note(new instance). * @type {Note} */ changeDuration(duration) { return new Note({note: this.note, octave: this.octave, instrument: this.instrument, duration: duration}) } /** * Gets interval size (Number) and returns a new instance of a note * which is calculated by the musical interval formula. * @example * let c = new Note({note:'c', octave:3}) //create a C3 note. * let interval = c.interval(4) //calling the function with the number 4(which is a major third). * console.log(interval.toStrring()) //should output 'E3'. * console.log(interval.constructor.name) //should output Note. * @param {number} interval Musical Interval */ interval(interval) { if (interval &gt;= 0) { const oct_diff = (this.index + interval) / 12 return new Note({ note: notes[this.family][(this.index + interval) % 12], octave: this.octave + parseInt(oct_diff), duration: this.duration, instrument: this.instrument }) } const oct_diff = this.index + interval &lt; 0 ? Math.floor((this.index + interval) / 12) : 0 return new Note({ note: notes[this.family][Math.abs((this.index + (12 + (interval % 12))) % 12)], octave: parseInt(this.octave) + parseInt(oct_diff), duration: this.duration, instrument: this.instrument }) } /** * ALias for interval() * @param {Number} interval */ transpose(interval) { return this.interval(interval) } // getMajorChord() { // return new Chord(this, this.interval(4), this.interval(7)) // } getMajorScale() { let scale = [this.note] for (let i of major_scale) { scale.push(this.interval(i)) } return toString(scale) } /** * Returns the note name and octave. * @example * 'C3' */ toString() { return this.note + this.octave } /** * Check if 2 notes are equal in letter and octave. * @param {Note} note */ isEqual(note) { if (this.note === note.note &amp;&amp; this.octave === note.octave) { return true } return false } /** * Returns string of the note fields formatted as an object. */ print() { return \"{Note: \" + this.note + \", Octave: \" + this.octave + \"}\" } /** * Play the note. */ play() { if (sounds.get( this.instrument + notes[\"b\"][notes[this.family].indexOf(this.note)] + this.octave ) instanceof Howl) { sounds.get( this.instrument + notes[\"b\"][notes[this.family].indexOf(this.note)] + this.octave ).play() // console.log(this.note, this.octave, this.frequency) } else { console.log( \"Cant find audio file\" ) } } } × Search results Close Music "},"Piece.js.html":{"id":"Piece.js.html","title":"Source: Piece.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: Piece.js import { Note, Rhythm, Sequence, Measure, Chord, note_durations } from '.' import { isArray, } from 'util' import { getMinDuration, twoDigitFormat } from './Addons'; export class Piece { constructor(bpm = 100, time_signature = [4, 4]) { this.attributes = [] this.attributes[Piece.RHYTHM] = new Rhythm(bpm, time_signature) this.attributes[Piece.DATA] = [] this.attributes[Piece.CURRENT_MEASURE] = 0 this.attributes[Piece.LISTS_OF_NOTES_LIST] = [] this.attributes[Piece.DURATION] = 0 } static get RHYTHM() { return 0 } static get DATA() { return 1 } static get LISTS_OF_NOTES_LIST() { return 2 } static get DURATION() { return 3 } static get CURRENT_MEASURE() { return 4 } get rhythm() { return this.attributes[Piece.RHYTHM] } get data() { return this.attributes[Piece.DATA] } set data(data) { this.attributes[Piece.DATA] = data this.notes = this.init() } /** * get the duration */ get duration() { return twoDigitFormat(this.attributes[Piece.DURATION]) } set duration(dur) { this.attributes[Piece.DURATION] = dur } get time_signature() { return this.rhythm.time_signature } get bpm() { return this.attributes[Piece.RHYTHM].bpm } set bpm(bpm) { this.rhythm.updateBPM(bpm) this.duration = this.calculateDuration() } get time_signature(){ return this.attributes[Piece.RHYTHM].time_signature } get ListsOfNotesList() { return this.attributes[Piece.LISTS_OF_NOTES_LIST] } set ListsOfNotesList(list) { this.attributes[Piece.LISTS_OF_NOTES_LIST] = list } get current_measure() { return this.attributes[Piece.CURRENT_MEASURE] } set current_measure(curr) { this.attributes[Piece.CURRENT_MEASURE] = curr } pushMeasure(measure) { if (measure instanceof Measure) { this.data.push(measure) measure.notes.forEach((notes) =&gt; { this.ListsOfNotesList.push(notes) this.duration += 60 / this.bpm * getMinDuration(notes) * this.rhythm.beats_per_measure }) } } pushMeasures(measure_list) { measure_list.forEach(measure =&gt; this.pushMeasure(measure)) } pushSequence(sequence) { sequence.measures.forEach(measure =&gt; this.pushMeasure(measure)) } pushSequences(sequences) { sequences.forEach((sequence) =&gt; { sequence.measures.forEach(measure =&gt; this.pushMeasure(measure)) }) } pushMandS(data){ data.forEach((d) =&gt; { if(d instanceof Measure) this.pushMeasure(d) else if(d instanceof Sequence) this.pushSequence(d) }) } popMeasure(){ this.data.splice(this.data.length-1, 1) } removeMeasure(measure_index){ this.data.splice(measure_index, 1) } calculateDuration() { let duration = 0 this.ListsOfNotesList.forEach(data =&gt; duration += 60 / this.bpm * getMinDuration(data) * this.rhythm.beats_per_measure) return duration } play() { this.rhythm.addMeasures(this.data) this.rhythm.toggle() } isPlaying() { return this.rhythm.isPlaying() } toString() { let string = 'Piece: { ' for (let i of this.data) string += i.toString() + ', ' string += '} ' return string } transpose(interval) { console.log(this.data) const newData = this.data.map(i =&gt; i.transpose(interval)) console.log(this.bpm, this.rhythm.time_signature) const new_piece = new Piece(this.bpm, this.time_signature) new_piece.pushMeasures(newData) return new_piece } } × Search results Close Music "},"RhythmOld.js.html":{"id":"RhythmOld.js.html","title":"Source: RhythmOld.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: RhythmOld.js import {Note, Chord, note_durations} from '.' import { isArray, } from 'util' var rhythm // for cross browser compatibility const AudioContext = window.AudioContext || window.webkitAudioContext //web audio api instance const audioCtx = new AudioContext() let min_interval = 1 / 16 //the interval at which the schedualer will be called and data will be able to be played. let next_interval = 0.0 //the time at which the next interval will be called updating with currentTime let next_note_time = 0.0 // when the next note is due. function scheduler() { // while there are notes that will need to play before the next interval, schedule them and advance the pointer. while (next_interval &lt; audioCtx.currentTime + rhythm.scheduleAheadTime) { rhythm.nextNote() } rhythm.timerID = setTimeout(scheduler, rhythm.lookahead) } /** * Creates a rhythm instance which holds bpm and time signature information. * @class */ export class Rhythm { constructor(bpm, time_signature) { this.data = null // the Sounds that will be played this.dataKeeper = null //will hold the music to reload it when it reaches the end this.reload_data = false //variable to dictate whether data needs to be reloaded or not this.metronome_sound = new Howl({ src: ['/static/Media/Metronome/1.wav'], }) this.metronome = false //metronome playing or not this.timerID = null //the timerID of the setInterval this.lookahead = 60 / this.bpm * min_interval // How frequently to call scheduling function (in // milliseconds) this.scheduleAheadTime = 0.1 // How far ahead to schedule audio (sec) this.current_beat = 1 //current beat this.notesInQueue = [] this.next_note = 1 this.lastNoteDrawn = 3 this.bpm = bpm this.beats_per_measure = time_signature[0] this.beat_duration = time_signature[1] this.isPlaying = false this.beat_check = 0 this.loop = true } static getRhythm() { if (rhythm) { return rhythm } rhythm = new Rhythm(60, [4, 4]) return rhythm } scheduleNote() { // push the note on the queue, even if we're not playing. if (this.data.length) { if (this.data[0]) { this.scheduleNoteHelper(this.data[0]) this.data.splice(0, 1) } } else { this.reload_data = true } } scheduleNoteHelper(data) { if (data instanceof Note || data instanceof Chord) { this.next_note = this.data.length ? note_durations[data.duration] : null console.log(data.toString()) data.play() } else if (isArray(data)) { let min_duration = note_durations[data.duration], playNow = [], curr_notes_playing = '' for (const n of data) { min_duration = min_duration &lt; note_durations[n.duration] ? min_duration : note_durations[n.duration] playNow.push(n) curr_notes_playing += n.toString() + ' ' } for (const n of playNow) n.play() console.log(curr_notes_playing) this.next_note = this.data.length ? min_duration : null } } nextNote() { var secondsPerBeat = 60 / this.bpm // tempo next_interval += secondsPerBeat * min_interval // Advance the beat number, wrap to zero this.beat_check += secondsPerBeat * min_interval if (this.beat_check &gt;= secondsPerBeat) { if (this.metronome) { this.metronome_sound.play() } this.beat_check = 0 this.current_beat++ if (this.current_beat === this.beats_per_measure + 1) { this.current_beat = 1 } } if (next_note_time &lt;= audioCtx.currentTime) { this.scheduleNote() next_note_time += secondsPerBeat * this.next_note * this.beats_per_measure // Add beat duration to last // beat time } } draw() { let drawNote = rhythm.lastNoteDrawn rhythm.currentTime = audioCtx.currentTime // while (rhythm.notesInQueue.length &amp;&amp; rhythm.notesInQueue[0].time &lt; rhythm.currentTime) { // drawNote = rhythm.notesInQueue[0].note // rhythm.notesInQueue.splice(0, 1) // remove note from queue // } // We only need to draw if the note has moved. if (rhythm.lastNoteDrawn != drawNote) { rhythm.lastNoteDrawn = drawNote } // set up to draw again requestAnimationFrame(rhythm.draw) } getBeat() { return this.current_beat } toggle() { rhythm = this this.start_time = audioCtx.currentTime if (this.reload_data) { this.reload_data = false this.data = this.dataKeeper } this.isPlaying = !this.isPlaying if (this.isPlaying) { // start playing // check if context is in suspended state (autoplay policy) if (audioCtx.state === 'suspended') { audioCtx.resume() } this.current_beat = 0 this.next_note = audioCtx.currentTime next_note_time = audioCtx.currentTime scheduler() // kick off scheduling requestAnimationFrame(this.draw) // start the drawing loop. } else { clearTimeout(this.timerID) } } addNotes(data) { this.data = data this.dataKeeper = JSON.parse(JSON.stringify(data)) } toggleMetronome() { if (rhythm) { rhythm.metronome = !rhythm.metronome } } } × Search results Close Music "},"Rhythm.js.html":{"id":"Rhythm.js.html","title":"Source: Rhythm.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: Rhythm.js import { Note, Chord, note_durations } from '.' import { isArray, } from 'util' import { getMinDuration } from './Addons'; let rhythm function scheduler() { // while there are notes that will need to play before the next interval, schedule them and advance the pointer. while (rhythm.next_interval &lt; rhythm.audioCtx.currentTime + rhythm.scheduleAheadTime) { if (rhythm.next_note &gt;= rhythm.data_with_time.length - 1) { for (let i = 0; i &lt; rhythm.calculate_ahead; i++) rhythm.scheduleNote() } rhythm.nextNote() } rhythm.timerID = setTimeout(scheduler, rhythm.lookahead) } /** * Creates a rhythm instance which holds bpm and time signature information. * @class */ export class Rhythm { /** * Create a new instance of rhythm. * @param {Number} bpm Speed of the rhythm in beats per minute * @param {Array} time_signature the number of notes per measure as an array [number_of_notes, type_of_notes] */ constructor(bpm, time_signature) { this.time_signature = time_signature this.data = null // the Sounds that will be played this.dataKeeper = null //will hold the music to reload it when it reaches the end this.reload_data = false //variable to dictate whether data needs to be reloaded or not this.metronome_sound = new Howl({ src: ['https://note-art.azurewebsites.net/Metronome/1.wav'], }) // for cross browser compatibility AudioContext = window.AudioContext || window.webkitAudioContext //web audio api instance this.audioCtx = new AudioContext() this.min_interval = 1 / 16 //the interval at which the schedualer will be called and data will be able to be // played. this.next_interval = 0.0 //the time at which the next interval will be called updating with currentTime this.calculate_ahead = 10 // how many notes to calculate precise time for ahead this.data_with_time = [] //Array which contains objects with sounds and time properties this.next_note = 0 //the next note which needs to be played this.next_note_to_schedule = 0 //the next note which needs to be scheduled and inserted to data_with_time this.overall_time = 0 //the overall time that passes when scheduling the notes(sum of start time and // every duration of every note scheduled) this.metronome = false //metronome playing or not this.timerID = null //the timerID of the setInterval this.lookahead = 10 // How frequently to call scheduling function (in milliseconds) this.scheduleAheadTime = 0.1 // How far ahead to schedule audio (sec) this.seconds_per_beat = 60 / bpm //beats per second - tempo this.current_beat = 1 //current beat this.lastNoteDrawn = 3 this.bpm = bpm this.beats_per_measure = time_signature[0] this.beat_duration = time_signature[1] this.is_playing = false this.beat_check = 0 this.loop = true } /** * returns a instance of rhythm to avoid creating more than one(a singleton) * @param {Number} bpm Speed of the rhythm in beats per minute * @param {Array} time_signature the number of notes per measure as an array [number_of_notes, type_of_notes] * @static */ static getRhythm(bpm = 80, time_signature = [4, 4]) { if (rhythm) { return rhythm } rhythm = new Rhythm(bpm, time_signature) return rhythm } /** * Schedual a note to be played at a specific time */ scheduleNote() { // push the note on the queue if (this.data[this.next_note_to_schedule]) { this.scheduleNoteHelper(this.data[this.next_note_to_schedule]) this.next_note_to_schedule++ } else { this.next_note_to_schedule = 0 } } /** * Helps the SchedualNote check what kind of data is dealt with at the moment and handles it. * @param {Array/Note/Chord} data */ scheduleNoteHelper(data) { this.data_with_time.push({ sounds: data, time: this.overall_time, }) this.overall_time += 60 / this.bpm * getMinDuration(data) * this.beats_per_measure } playSounds() { for (const i of this.data_with_time[this.next_note].sounds) { console.log(i.toString()) i.play() } } /** * Advances to the next note and updates the beat */ nextNote() { this.next_interval += this.seconds_per_beat * this.min_interval // Advance the beat number, wrap to zero this.beat_check += this.seconds_per_beat * this.min_interval if (this.prev_beat_time + this.seconds_per_beat &lt;= this.audioCtx.currentTime) { // console.log(this.prev_beat_time - this.start_time) if (this.metronome) { this.metronome_sound.play() } // console.log(audioCtx.currentTime - this.start_time) this.beat_check = 0 this.current_beat++ if (this.current_beat === this.beats_per_measure + 1) { this.current_beat = 1 } this.prev_beat_time += this.seconds_per_beat } if (this.data_with_time[this.next_note]) { if (this.data_with_time[this.next_note].time &lt;= this.audioCtx.currentTime) { // console.log(this.data_with_time[this.next_note].time - this.start_time) this.playSounds() this.next_note++ } } } draw() { let drawNote = rhythm.lastNoteDrawn rhythm.currentTime = rhythm.audioCtx.currentTime // We only need to draw if the note has moved. if (rhythm.lastNoteDrawn != drawNote) { rhythm.lastNoteDrawn = drawNote } // set up to draw again requestAnimationFrame(rhythm.draw) } isPlaying() { return this.is_playing } getBeat() { return this.current_beat } toggle(index = 0) { rhythm = this this.is_playing = !this.is_playing if (this.is_playing) { // start playing // check if context is in suspended state (autoplay policy) if (this.audioCtx.state === 'suspended') { this.audioCtx.resume() } this.start_time = this.audioCtx.currentTime this.overall_time = this.audioCtx.currentTime this.prev_beat_time = this.audioCtx.currentTime this.data_with_time.length = 0 this.next_note = index this.current_beat = 1 this.next_note_to_schedule = index scheduler() // kick off scheduling // requestAnimationFrame(this.draw) // start the drawing loop. } else { clearTimeout(this.timerID) } } addNotes(data) { this.data = data } addMeasures(measures){ this.data = [] measures.forEach(measure =&gt; { measure.notes.forEach(notes =&gt; { this.data.push(notes) }) }) } toggleMetronome() { if (rhythm) { rhythm.metronome = !rhythm.metronome } } updateBPM(bpm) { this.bpm = bpm this.seconds_per_beat = 60 / bpm if (this.is_playing == true) { this.toggle() this.toggle() } } } × Search results Close Music "},"Sequence.js.html":{"id":"Sequence.js.html","title":"Source: Sequence.js","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Source: Sequence.js import { Measure } from \"./Measure\"; export class Sequence { constructor() { this.attributes = [] this.attributes[Sequence.MEASURES] = [] this.attributes[Sequence.DURATION] = 0 } static get MEASURES() { return 0 } static get DURATION() { return 1 } get measures() { return this.attributes[Sequence.MEASURES] } set measures(data) { this.attributes[Sequence.MEASURES] = data } /** * get the duration */ get duration() { return this.attributes[Sequence.DURATION] } /** * set the duration */ set duration(duration) { this.attributes[Sequence.DURATION] = duration } getData() { const data = [] this.measures.forEach((i) =&gt; { i.notes.forEach(j =&gt; data.push(j)) }) return data } /** * Push measure to sequence * @param {Measure} measure */ push(measure) { if (measure instanceof Measure) this.measures.push(measure) } /** * Pushes a group of measures * @param {Array} measures array if measures */ pushMeasures(measures) { measures.forEach(measure =&gt; this.measures.push(measure)) } transpose(interval) { const newMeasures = this.measures.map(m =&gt; m.transpose(interval)) return new Sequence(newMeasures) } toString() { let string = 'Sequence: { ' this.measures.forEach((i) =&gt; { string += i.toString() + ', ' }) string += '}' return string } } × Search results Close Music "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Classes Classes Chord DiatonicScale Key Measure MusicalPattern Note Rhythm Rhythm × Search results Close Music "},"index.html":{"id":"index.html","title":"Index","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm A Work in progressNote-Art JS Music is a highly versatile art that originates in nature, and has been taken up by mankind as a way of expression and also as an art.Now, it's going to be taken up by machines as well. This project aims to create a library that implements all of music theory(in all it's forms) in code,can be used to play sounds of most musical instruments.It will then be used to create multiple tools for people to practice, learn, enjoy and compose.it will also be used to attempt development of different projects combining music and AI. “Everything is determined … by forces over which we have nocontrol. It is determined for the insects as well as for the star.Human beings, vegetables, or cosmic dust – we all dance to amysterious tune, intoned in the distance by an invisible piper.”– Albert Einstein Table of Contents- Installation- Basic Use Installation# go to project folder npm install note-artBasic Use Musical Project By Sean Dvir × Search results Close Music "},"Chord.html":{"id":"Chord.html","title":"Class: Chord","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Class: Chord Chord represents a Chord. new Chord(attributes) Creates a Chord instance. Parameters: Name Type Description attributes Object gets{Note/String} root{Note/String} third{Note/String} fifth{Note/String} note4(optional){String} duration Source: Chord.js, line 9 Members &lt;static, readonly&gt; FIFTH :Number The index of the fifth. Type: Number Source: Chord.js, line 212 &lt;static, readonly&gt; NOTE4 :Number The index of the fourth note. Type: Number Source: Chord.js, line 221 &lt;static, readonly&gt; ROOT :Number The index of the root. Type: Number Source: Chord.js, line 194 &lt;static, readonly&gt; THIRD :Number The index of the third. Type: Number Source: Chord.js, line 203 &lt;readonly&gt; duration The duration of the chord as String Source: Chord.js, line 266 &lt;readonly&gt; fifth The fifth of the chord as Note Source: Chord.js, line 248 &lt;readonly&gt; note4 The fourth note of the chord as Note Source: Chord.js, line 257 &lt;readonly&gt; root The root of the chord as Note Source: Chord.js, line 230 &lt;readonly&gt; third The third of the chord as Note Source: Chord.js, line 239 Methods inversionFirst() Transforms the chord into its 1st-inversion. Source: Chord.js, line 309 inversionSecond() Transforms the chord into its 2st-inversion. Source: Chord.js, line 316 play() play all the notes in the chord as a harmony. Source: Chord.js, line 294 playMelody() play all the notes in the chord as a melody. Source: Chord.js, line 282 rootPosition() Transforms the chord into its root position. Source: Chord.js, line 302 toString() returns string of the name of the chord and all the notes it contains. Source: Chord.js, line 323 × Search results Close Music "},"DiatonicScale.html":{"id":"DiatonicScale.html","title":"Class: DiatonicScale","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Class: DiatonicScale DiatonicScale represents a Diatonic Scale(a scale that consists of 7 notes), new DiatonicScale(tonic, pattern) Parameters: Name Type Description tonic Note/String Root of the Scale pattern Array Intervals for the other notes(from the tonic). Source: Scale.js, line 7 Extends MusicalPattern Members notes returns array that contains all the notes in the pattern. Inherited From: MusicalPattern#notes Source: MusicalPattern.js, line 33 Methods getChord(chord) returns the x chord of the scale. Parameters: Name Type Description chord number Chord Number Source: Scale.js, line 29 getChords() returns array with all the chords in the scale. Source: Scale.js, line 36 interval(interval) returns the interval inside the Scalefor example - if the Scale is a C Major,than interval(1) wiil return D. Parameters: Name Type Description interval number Inherited From: MusicalPattern#interval Source: MusicalPattern.js, line 53 play() play all the notes in the pattern one after the other. Inherited From: MusicalPattern#play Source: MusicalPattern.js, line 63 toString() returns a string of all the notes in the pattern Inherited From: MusicalPattern#toString Source: MusicalPattern.js, line 40 × Search results Close Music "},"Key.html":{"id":"Key.html","title":"Class: Key","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Class: Key Key represents a Musical Key that is based on a specific Diatonic Scale., new Key() Source: Key.js, line 7 Extends DiatonicScale Methods getChord(chord) returns the x chord of the scale. Parameters: Name Type Description chord number Chord Number Inherited From: DiatonicScale#getChord Source: Scale.js, line 29 getChords() returns array with all the chords in the scale. Inherited From: DiatonicScale#getChords Source: Scale.js, line 36 × Search results Close Music "},"Measure.html":{"id":"Measure.html","title":"Class: Measure","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Class: Measure Measure Measure - represents a single measure as part of a musical piece. new Measure(data, max_duration) Creates a Measure instance Parameters: Name Type Description data Array An array which contains notes or chords max_duration Number Max duration of the measure(decided by time signature) Source: Measure.js, line 17 Members duration get the duration Source: Measure.js, line 67 duration set the duration Source: Measure.js, line 74 notes Assign new notes to measure Source: Measure.js, line 51 notes Array of all the notes in the measure Source: Measure.js, line 44 Methods getData() Returns a new array with the same notes. Source: Measure.js, line 58 mutate(index, new_notes) Change notes somewhere inside a measure Parameters: Name Type Description index Number The index where the notes will be changed new_notes Array/Note Notes to change to Source: Measure.js, line 91 push(notes) Push notes to a measure Parameters: Name Type Description notes Array array of notes Source: Measure.js, line 107 pushNotes(note_arrays) Add notes to the end of the measure Parameters: Name Type Description note_arrays Array array of arrays of notes Source: Measure.js, line 121 × Search results Close Music "},"MusicalPattern.html":{"id":"MusicalPattern.html","title":"Class: MusicalPattern","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Class: MusicalPattern MusicalPattern Represents a musical pattern. new MusicalPattern(tonic, pattern) Parameters: Name Type Description tonic String/Note pattern Array Source: MusicalPattern.js, line 9 Members notes returns array that contains all the notes in the pattern. Source: MusicalPattern.js, line 33 Methods interval(interval) returns the interval inside the Scalefor example - if the Scale is a C Major,than interval(1) wiil return D. Parameters: Name Type Description interval number Source: MusicalPattern.js, line 53 play() play all the notes in the pattern one after the other. Source: MusicalPattern.js, line 63 toString() returns a string of all the notes in the pattern Source: MusicalPattern.js, line 40 × Search results Close Music "},"Note.html":{"id":"Note.html","title":"Class: Note","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Class: Note Note Represents a single musical note. new Note(attributes) Parameters: Name Type Description attributes Object Object that contains some or all of the following keys:{String} note Musical Note{number} octave Note Octave{String} duration Note duration{String} instrument Piano/Guitar/etc... Source: Note.js, line 19 Example const n = new Note({note: 'c', octave: 3, duration: 'q', instrument: 'Piano'}) Members &lt;static, readonly&gt; DURATION :Number Index of duration in attributes Type: Number Source: Note.js, line 64 &lt;static, readonly&gt; FAMILY :Number Index of family in attributes Type: Number Source: Note.js, line 82 &lt;static, readonly&gt; FREQUENCY :Number Index of frequency in attributes Type: Number Source: Note.js, line 100 &lt;static, readonly&gt; INDEX :Number Index of note index in attributes Type: Number Source: Note.js, line 91 &lt;static, readonly&gt; INSTRUMENT :Number Index of instrument in attributes Type: Number Source: Note.js, line 73 &lt;static, readonly&gt; NOTE :Number Index of note in attributes Type: Number Source: Note.js, line 46 &lt;static, readonly&gt; OCTAVE :Number Index of octave in attributes Type: Number Source: Note.js, line 55 &lt;readonly&gt; duration :String Get the duration of a note Type: String Source: Note.js, line 155 family :String Set the notes family in case needed. Type: String Source: Note.js, line 181 &lt;readonly&gt; family :String Get the family of notes the note belnogs to - sharps or flats Type: String Source: Note.js, line 173 &lt;readonly&gt; frequency :String Get the frequency of the note. Type: String Source: Note.js, line 199 &lt;readonly&gt; index :String Get the index of the note from the 12 notes (C, Db, etc...). Type: String Source: Note.js, line 190 &lt;readonly&gt; instrument :String Get the instrument that plays the note Type: String Source: Note.js, line 164 &lt;readonly&gt; note :String Returns the note alphabet representation as a string. Type: String Source: Note.js, line 137 &lt;readonly&gt; octave :Number Get octave of note. Type: Number Source: Note.js, line 146 Methods changeDuration() returns a clone of the note(new instance). Source: Note.js, line 230 clone() returns a clone of the note(new instance). Source: Note.js, line 217 interval(interval) Gets interval size (Number) and returns a new instance of a notewhich is calculated by the musical interval formula. Parameters: Name Type Description interval number Musical Interval Source: Note.js, line 244 Example let c = new Note({note:'c', octave:3}) //create a C3 note. let interval = c.interval(4) //calling the function with the number 4(which is a major third). console.log(interval.toStrring()) //should output 'E3'. console.log(interval.constructor.name) //should output Note. isEqual(note) Check if 2 notes are equal in letter and octave. Parameters: Name Type Description note Note Source: Note.js, line 296 play() Play the note. Source: Note.js, line 313 print() Returns string of the note fields formatted as an object. Source: Note.js, line 306 toString() Returns the note name and octave. Source: Note.js, line 288 Example 'C3' transpose(interval) ALias for interval() Parameters: Name Type Description interval Number Source: Note.js, line 268 × Search results Close Music "},"Rhythm.html":{"id":"Rhythm.html","title":"Class: Rhythm","body":" Note-Art Classes ChordDiatonicScaleKeyMeasureMusicalPatternNoteRhythm Class: Rhythm Rhythm Creates a rhythm instance which holds bpm and time signature information. new Rhythm() Source: RhythmOld.js, line 27 Methods &lt;static&gt; getRhythm(bpm, time_signature) returns a instance of rhythm to avoid creating more than one(a singleton) Parameters: Name Type Default Description bpm Number 80 Speed of the rhythm in beats per minute time_signature Array the number of notes per measure as an array [number_of_notes, type_of_notes] Source: Rhythm.js, line 89 nextNote() Advances to the next note and updates the beat Source: Rhythm.js, line 132 scheduleNote() Schedual a note to be played at a specific time Source: Rhythm.js, line 100 scheduleNoteHelper(data) Helps the SchedualNote check what kind of data is dealt with at the moment and handles it. Parameters: Name Type Description data Array/Note/Chord Source: Rhythm.js, line 114 Class: Rhythm Rhythm Creates a rhythm instance which holds bpm and time signature information. new Rhythm(bpm, time_signature) Create a new instance of rhythm. Parameters: Name Type Description bpm Number Speed of the rhythm in beats per minute time_signature Array the number of notes per measure as an array [number_of_notes, type_of_notes] Source: Rhythm.js, line 32 Methods &lt;static&gt; getRhythm(bpm, time_signature) returns a instance of rhythm to avoid creating more than one(a singleton) Parameters: Name Type Default Description bpm Number 80 Speed of the rhythm in beats per minute time_signature Array the number of notes per measure as an array [number_of_notes, type_of_notes] Source: Rhythm.js, line 89 nextNote() Advances to the next note and updates the beat Source: Rhythm.js, line 132 scheduleNote() Schedual a note to be played at a specific time Source: Rhythm.js, line 100 scheduleNoteHelper(data) Helps the SchedualNote check what kind of data is dealt with at the moment and handles it. Parameters: Name Type Description data Array/Note/Chord Source: Rhythm.js, line 114 × Search results Close Music "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
